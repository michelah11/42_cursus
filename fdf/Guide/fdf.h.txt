File: fdf.h
This is the main header file for the fdf project, containing all the necessary includes, macro definitions, enumerations, and type
definitions used throughout the program. It also declares all the functions used in the project.

Includes:

# include <stdlib.h>			// Standard library functions (e.g., malloc, free)
# include <unistd.h>			// Unix standard functions (e.g., read, write)
# include <fcntl.h>				// File control options (e.g., open)
# include <math.h>				// Math functions (e.g., cos, sin)
# include "../minilibx/mlx.h" 	// MiniLibX for graphical interface
# include "libft.h"				// Custom C library functions
# include "get_next_line.h"		// Function to read lines from a file
# include "keys.h"				// Definitions of keycodes used in the program
# include "colors.h"			// Definitions of color codes

Macro Definitions:

- Window and Image Settings:
# define WINDOW_NAME			"fdf"		// Title of the window
# define WINDOW_WIDTH			1200		// Width of the window in pixels
# define WINDOW_HEIGHT			900			// Height of the window in pixels
# define MAX_PIXEL				1080000		// Maximum number of pixels in the image (1200 * 900)

- Colors Configuration:
# define LINE_DEFAULT				C_WHITE		// Default line color (white)
# define BACKGROUND_DEFAULT		C_GREY		// Default background color (grey)
# define C_TEXT					C_WHITE		// Default text color (white)

- Conversion Bases & Useful Angles:
# define HEXADECIMAL_L_BASE		"0123456789abcdef"	// Hexadecimal base for conversions
# define ANG_D_1				0.01745329	// 1 degree in radians
# define ANG_D_30					0.52359877	// 30 degrees in radians
# define ANG_D_45					0.78539816	// 45 degrees in radians

Enumerations:

- e_projection: Enumerator for the different projection modes.
enum e_projection
{
	ISOMETRIC,	// Isometric projection
	PERSPECTIVE,	// Perspective projection
	TOP			// Top-down view projection
};

- e_bool: Enumerator for boolean values.
enum e_bool
{
	FALSE,		// Boolean false (0)
	TRUE		// Boolean true (1)
};

Type Definitions:

- t_point:  structure used to represent a single point in 3D space. This includes its position in 3D (x, y, z) and its color.
	- 3D Coordinates: By storing x, y, and z as floats, the structure can represent the precise location of a point in 3D space.
	- Color: Inclusion of a color property allows for each point to have an associated color, which is necessary for rendering
					colored images or gradients.
typedef struct s_point
{
	float	x;	// X coordinate
	float	y;	// Y coordinate
	float	z;	// Z coordinate (height)
	int		color; // Color of the point
} t_point;

- t_map: structure representing the entire map or grid of points that make up the 3D model. It organizes these points and stores
		metadata about the map, such as its dimensions and the range of its z-values.
		- 2D Array of Points: The coordinates field as a 2D array allows the program to easily access any point on the map by
				its x and y indices.
		- Map Dimensions: The max and min values for x, y, and z provide important information about the scale and bounds of themap.
typedef struct s_map
{
	t_point **coordinates;	// 2D array of points (map coordinates)
	int	max_x;				// Maximum X value (width of the map)
	int	max_y;				// Maximum Y value (height of the map)
	int	max_z;				// Maximum Z value (height of the map)
	int	min_z;				// Minimum Z value (depth of the map)
} t_map;

- t_line: structure representing a line segment in 3D space, defined by a starting point and an ending point. The additional transform_z
		is used for perspective transformations.
		- Starting and Ending Points: By explicitly defining the start and end points as t_point structures, the program can perform
				operations like rendering, scaling, and transforming lines with ease.
		- Perspective Projection: The transform_z value is necessary for perspective projections, which involve transforming the z-coordinate
				to simulate depth on a 2D plane.
typedef struct s_line
{
	t_point	start;			// Starting point of the line
	t_point	end;			// Ending point of the line
	float	transform_z;	// Z transformation value for perspective projection
} t_line;

- t_color: structure used to handle color gradients, which are transitions between two colors. It stores both the starting and ending
		colors, as well as the differences between their components
		- Color Gradients: By storing the start and end colors and their RGB components separately, this structure enables smooth color transitions.
		- Delta Values: The differences (deltas) between the color components allow for easy calculation of intermediate colors, facilitating gradient rendering.
typedef struct s_color
{
	int	start_color;	// Starting color
	int	start_r;		// Red component of the starting color
	int	start_g;		// Green component of the starting color
	int	start_b;		// Blue component of the starting color
	int	end_color;		// Ending color
	int	end_r;			// Red component of the ending color
	int	end_g;			// Green component of the ending color
	int	end_b;			// Blue component of the ending color
	int	delta_r;		// Difference in red component between start and end colors
	int	delta_g;		// Difference in green component between start and end colors
	int	delta_b;		// Difference in blue component between start and end colors
} t_color;


- t_image: structure holding information about an image that is being generated or displayed by the program.
		- Image Buffer: The buffer is where pixel data is stored, and itâ€™s crucial for directly manipulating
				the image that will be displayed on the screen.
		- Line Rendering: The inclusion of a t_line pointer allows for easy access to the current line being
				rendered, making it efficient to draw and update the image.
typedef struct s_image
{
	void	*image;		// Image pointer
	int	pixel_bits;		// Number of bits per pixel
	int	line_bytes;		// Number of bytes per line
	int	endian;			// Endianness of the image
	char	*buffer;	// Pointer to the image buffer
	t_line	*line;		// Pointer to the current line being rendered
} t_image;


- t_cam: structure representing the camera settings in the program. It defines how the 3D model is viewed, including
		its projection mode, scale, translation (panning), and rotation.
		- Projection and View Control: The projection mode and rotation angles (alpha, beta, gamma) allow for various
				ways to view and manipulate the 3D model, essential for creating dynamic visualizations.
		- Panning and Zooming: The scale factors and translation values enable zooming and moving the camera, providing
				control over how the model is displayed on the screen.
		- Color Pallet Toggle: This allows the user to switch between different color schemes or gradients, enhancing
				the visual representation.
typedef struct s_cam
	{
	int		projection;			// Current projection mode (e.g., ISOMETRIC)
	int		color_pallet;		// Boolean to toggle color pallet
	float	scale_factor;		// Scale factor for zooming
	float	scale_z;			// Z-axis scale factor
	float	move_x;				// X-axis translation (panning)
	float	move_y;				// Y-axis translation (panning)
	double	alpha;				// Rotation angle around X-axis
	double	beta;				// Rotation angle around Y-axis
	double	gamma;				// Rotation angle around Z-axis
} t_cam;


- t_fdf: Main structure structure encapsulates the entire state of the fdf program, holding pointers to all major components
		like the map, the image being rendered, the camera settings, and the MLX instance.
		- Centralized Control: By encapsulating everything in t_fdf, the program can easily manage and pass around the state,
				ensuring that all components (map, image, camera) are coordinated during operations like rendering.
		- Modularity: Each component (map, image, camera) is represented by its own structure, which simplifies the program's
				design and makes the codebase more modular and easier to maintain or extend.
		- MLX Integration: Including the MLX instance and window within this structure ties the rendering loop and event handling
				directly to the data that controls the visualization, making the program more cohesive and easier to manage.
typedef struct s_fdf
{
	t_map		*map;			// Pointer to the map structure
	void		*mlx;			// Pointer to the MLX instance
	int		win_x;		// Window width
	int		win_y;		// Window height
	void		*win;			// Pointer to the window
	t_image	*image;		// Pointer to the image structure
	t_cam		*cam;			// Pointer to the camera structure
} t_fdf;


Function Prototypes:

- Mathematical Utilities:
float get_min(float a, float b);			// Returns the minimum of two floats
float get_max(float a, float b);			// Returns the maximum of two floats
float absolute(float n);				// Returns the absolute value of a float


- Transformations:
void transform(t_cam *cam, t_line *line);					// Applies transformations to a line based on camera settings
void translate(t_line *line, int move_x, int move_y);		// Translates a line by given x and y values
void scale(t_line *line, int scale_factor);					// Scales a line by a given factor
void rotate(t_cam *cam, t_line *line);						// Rotates a line based on camera angles
void rotate_x(t_line *line, double angle);					// Rotates a line around the X-axis
void rotate_y(t_line *line, double angle);					// Rotates a line around the Y-axis
void rotate_z(t_line *line, double angle);					// Rotates a line around the Z-axis


- Rendering and Display:
void render(t_fdf *fdf);						// Renders the entire map
t_map *read_map(char *file_name);				// Reads and parses the map from a file
void project(t_cam *cam, t_line *line);			// Projects a line based on the current projection mode
void print_menu(t_fdf *fdf);					// Displays the on-screen menu


- Initialization:
t_line	*init_line(t_point start, t_point end, t_fdf *fdf);			// Initializes a line structure
t_cam	*init_cam(t_map *map);										// Initializes the camera settings
t_image	*init_image(void *mlx);										// Initializes the image structure
t_map	*init_map(void);											// Initializes the map structure
t_fdf	*init_fdf(char *file_name);									// Initializes the main fdf structure
void	reset(t_fdf *fdf);											// Resets the camera and rendering settings
float	scale_to_fit(t_map *map);									// Calculates the scale factor to fit the map in the window
void	center_to_origin(t_map *map);								// Centers the map coordinates around the origin
t_point	init_coordinates(int width, int depth);						// Initializes the map's coordinate array


- Error Handling:
void error_by_code(int exit_code);				// Handles errors and exits the program with a message


- Drawing Utilities:
void bresenham(t_fdf *fdf, t_point start, t_point end);  // Draws a line using the Bresenham algorithm
void pixels_to_image(t_image *image, float x, float y, int color); // Draws a pixel to the image buffer
void clear_image(t_image *image, int image_size); // Clears the image buffer


- Color Utilities:
int get_color(t_color *color, int i_line, int line_size); // Gets the color at a specific point along a gradient
t_color *color_init(t_point start, t_point end); // Initializes a color structure based on two points
t_color *color_pallet_init(int min_color, int max_color); // Initializes a color gradient


- Closing and Exiting:
void close_all(t_fdf *fdf, int exit_code);	// Closes all resources and exits the program
void close_map(t_fdf *fdf, int exit_code);	// Closes the map and associated resources


- String and File Utilities:
int ft_atoi_base(char *str, char *base);		// Converts a string to an integer based on a given base
size_t split_count(const char *s, char c);	// Counts the number of splits in a string based on a delimiter



File: close.c
This file contains functions for safely closing and freeing resources used in the program.

Functions:

1. close_coordinates(t_point coordinates, int width):
	- Purpose: Frees the memory allocated for the 2D array of coordinates.
	- Parameters:
		- t_point coordinates: The 2D array of points to free.
		- int width: The width of the array (number of rows).
	- Code Documentation:

	static void close_coordinates(t_point coordinates, int width) {
		int i = 0;	// Index for iterating through rows

		// Free each row in the array
		while (i < width) {
			free(coordinates[i]);
			i++;
		}
		free(coordinates);	// Free the array of pointers itself
	}


2. close_all(t_fdf *fdf, int exit_code):
	- Purpose: Frees all allocated resources and exits the program.
	- Parameters:
		- t_fdf *fdf: The main structure containing all allocated resources.
		- int exit_code: The exit code to return upon termination.
	- Code Documentation:

	void close_all(t_fdf *fdf, int exit_code) {
		close_coordinates(fdf->map->coordinates, fdf->map->max_x);	// Free map coordinates
		free(fdf->map);	// Free the map structure
		mlx_destroy_image(fdf->mlx, fdf->image->image);	// Destroy the image
		free(fdf->image);	// Free the image structure
		free(fdf->cam);	// Free the camera structure
		mlx_destroy_window(fdf->mlx, fdf->win);	// Destroy the window
		mlx_destroy_display(fdf->mlx);	// Destroy the display
		free(fdf->mlx);	// Free the MLX instance
		free(fdf);	// Free the main fdf structure
		error_by_code(exit_code);	// Call the error handler with the exit code
	}


3. close_map(t_fdf *fdf, int exit_code):
	- Purpose: Frees the map-related resources and exits the program.
	- Parameters:
	- t_fdf *fdf: The main structure containing the map resources.
	- int exit_code: The exit code to return upon termination.
	- Code Documentation:

	void close_map(t_fdf *fdf, int exit_code) {
		close_coordinates(fdf->map->coordinates, fdf->map->max_x);	// Free map coordinates
		free(fdf->map);	// Free the map structure
		mlx_destroy_window(fdf->mlx, fdf->win);	// Destroy the window
		mlx_destroy_display(fdf->mlx);	// Destroy the display
		free(fdf);	// Free the main fdf structure
		error_by_code(exit_code);	// Call the error handler with the exit code
	}


File: color.c


This file handles color gradients and color initialization for drawing in the program.

Functions:

1. color_gradient(t_color *color, float progress):
	- Purpose: Computes a color based on the progress between two colors in a gradient.
	- Parameters:
	- t_color *color: The structure holding color information and deltas.
	- float progress: A value between 0 and 1 representing the progress.
	- Returns: The computed color.
	- Code Documentation:

	static int color_gradient(t_color *color, float progress) {
		int r, g, b;

		r = color->delta_r * progress;	// Calculate red channel gradient
		if (r < -255) r = 0;
		else if (r > 255) r = 255;
		r = r << 16;	// Shift red to its correct position in the color integer

		g = color->delta_g * progress;	// Calculate green channel gradient
		if (g < -255) g = 0;
		else if (g > 255) g = 255;
		g = g

 << 8;	// Shift green to its correct position

		b = color->delta_b * progress;	// Calculate blue channel gradient
		if (b < -255) b = 0;
		else if (b > 255) b = 255;

		return (color->start_color + r + g + b);	// Combine the channels to get the final color
	}


2. get_color(t_color *color, int i_line, int line_size):
	- Purpose: Gets a color based on the position along a line.
	- Parameters:
	- t_color *color: The structure holding color gradient information.
	- int i_line: The current position along the line.
	- int line_size: The total length of the line.
	- Returns: The color at the given position.
	- Code Documentation:

	int get_color(t_color *color, int i_line, int line_size) {
		float progress = (float) i_line / (float) line_size;	// Calculate the progress as a fraction
		return color_gradient(color, progress);	// Get the color based on the progress
	}


3. color_init(t_point start, t_point end):
	- Purpose: Initializes a t_color structure for a gradient between two points.
	- Parameters:
	- t_point start: The starting point of the gradient.
	- t_point end: The ending point of the gradient.
	- Returns: A pointer to the initialized t_color structure, or NULL on failure.
	- Code Documentation:

	t_color *color_init(t_point start, t_point end) {
		t_color *color;

		color = malloc(sizeof(t_color));	// Allocate memory for the color structure
		if (!color)
			return (NULL);	// Return NULL if allocation fails

		color->start_color = start.color;	// Initialize start color
		color->start_r = (C_RED & start.color) >> 16;	// Extract red component
		color->start_g = (C_GREEN & start.color) >> 8;	// Extract green component
		color->start_b = (C_BLUE & start.color);	// Extract blue component

		color->end_color = end.color;	// Initialize end color
		color->end_r = (C_RED & end.color) >> 16;
		color->end_g = (C_GREEN & end.color) >> 8;
		color->end_b = (C_BLUE & end.color);

		color->delta_r = (color->end_r - color->start_r);	// Calculate delta for red
		color->delta_g = (color->end_g - color->start_g);	// Calculate delta for green
		color->delta_b = (color->end_b - color->start_b);	// Calculate delta for blue

		return (color);	// Return the initialized color structure
	}


4. color_pallet_init(int min_color, int max_color):
	- Purpose: Initializes a t_color structure for a gradient between two colors.
	- Parameters:
	- int min_color: The starting color.
	- int max_color: The ending color.
	- Returns: A pointer to the initialized t_color structure, or NULL on failure.
	- Code Documentation:

	t_color *color_pallet_init(int min_color, int max_color) {
		t_color *color;

		color = malloc(sizeof(t_color));	// Allocate memory for the color structure
		if (!color)
			return (NULL);	// Return NULL if allocation fails

		color->start_color = min_color;	// Initialize start color
		color->start_r = (C_RED & min_color) >> 16;
		color->start_g = (C_GREEN & min_color) >> 8;
		color->start_b = (C_BLUE & min_color);

		color->end_color = max_color;	// Initialize end color
		color->end_r = (C_RED & max_color) >> 16;
		color->end_g = (C_GREEN & max_color) >> 8;
		color->end_b = (C_BLUE & max_color);

		color->delta_r = (color->end_r - color->start_r);	// Calculate delta for red
		color->delta_g = (color->end_g - color->start_g);	// Calculate delta for green
		color->delta_b = (color->end_b - color->start_b);	// Calculate delta for blue

		return (color);	// Return the initialized color structure
	}


File: draw.c


This file contains the functions responsible for drawing lines on the screen using the Bresenham algorithm, as well as functions for managing the image buffer.

Functions:

1. bresenham(t_fdf *fdf, t_point start, t_point end):
	- Purpose: Draws a line between two points using the Bresenham algorithm.
	- Parameters:
	- t_fdf *fdf: The main structure containing image and rendering information.
	- t_point start: The starting point of the line.
	- t_point end: The ending point of the line.
	- Code Documentation:

	void bresenham(t_fdf *fdf, t_point start, t_point end) {
		float x_step, y_step;
		int max_steps;
		int i_line;
		t_color *color;

		x_step = end.x - start.x;	// Calculate the difference in x
		y_step = end.y - start.y;	// Calculate the difference in y
		max_steps = (int)get_max(absolute(x_step), absolute(y_step));	// Determine the number of steps based on the greater difference

		x_step /= max_steps;	// Normalize the x_step
		y_step /= max_steps;	// Normalize the y_step

		color = color_init(start, end);	// Initialize color gradient between the start and end points
		if (!color)
			close_all(fdf, 8);	// Handle error if color initialization fails

		i_line = 0;
		while (i_line < max_steps) {
			start.color = get_color(color, i_line++, max_steps);	// Get the current color based on progress
			if (start.x > 0 && start.y > 0 && start.x < WINDOW_WIDTH && start.y < WINDOW_HEIGHT)
				pixels_to_image(fdf->image, start.x, start.y, start.color);	// Draw the pixel in the image buffer

			start.x += x_step;	// Increment x position
			start.y += y_step;	// Increment y position
		}
		free(color);	// Free the color structure
	}


2. pixels_to_image(t_image *image, float x, float y, int color):
	- Purpose: Draws a pixel in the image buffer at the specified coordinates.
	- Parameters:
	- t_image *image: The image structure containing the buffer.
	- float x: The x-coordinate of the pixel.
	- float y: The y-coordinate of the pixel.
	- int color: The color of the pixel.
	- Code Documentation:

	void pixels_to_image(t_image *image, float x, float y, int color) {
		int pixel;

		pixel = ((int)y * image->line_bytes) + ((int)x * 4);	// Calculate the pixel's position in the buffer

		// Handle endian-ness when writing the color to the buffer
		if (image->endian == 1) {
			image->buffer[pixel + 0] = (color >> 24);		// Write red channel
			image->buffer[pixel + 1] = (color >> 16) & 0xff;	// Write green channel
			image->buffer[pixel + 2] = (color >> 8) & 0xff;	// Write blue channel
			image->buffer[pixel + 3] = (color) & 0xff;		// Write alpha channel
		}
		else if (image->endian == 0) {
			image->buffer[pixel + 0] = (color) & 0xff;		// Write alpha channel
			image->buffer[pixel + 1] = (color >> 8) & 0xff;	// Write blue channel
			image->buffer[pixel + 2] = (color >> 16) & 0xff;	// Write green channel
			image->buffer[pixel + 3] = (color >> 24);		// Write red channel
		}
	}


3. clear_image(t_image *image, int image_size):
	- Purpose: Clears the image buffer by setting it to a default background color.
	- Parameters:
	- t_image *image: The image structure containing the buffer.
	- int image_size: The size of the image buffer.
	- Code Documentation:

	void clear_image(t_image *image, int image_size) {
		int x, y;

		ft_bzero(image->buffer, image_size);	// Clear the buffer

		// Fill the buffer

 with the default background color
		y = 0;
		while (y < WINDOW_HEIGHT) {
			x = 0;
			while (x < WINDOW_WIDTH) {
				pixels_to_image(image, x, y, BACKGROUND_DEFAULT);	// Set each pixel to the background color
				x++;
			}
			y++;
		}
	}

File: main.c
This file contains the entry point (main function) of the program and sets up the main loop for rendering and handling events.

Functions:

1. key_press_handle(t_fdf *fdf):
	- Purpose: Handles the expose event (when the window needs to be redrawn).
	- Parameters:
	- t_fdf *fdf: The main structure containing rendering information.
	- Returns: 0 after handling the event.
	- Code Documentation:

	static int key_press_handle(t_fdf *fdf) {
		render(fdf);	// Re-render the scene when the window is exposed
		return (0);	// Return 0 to indicate successful handling
	}


2. main(int argc, char argv):
	- Purpose: The entry point of the program. Initializes the program, processes input, and enters the main event loop.
	- Parameters:
	- int argc: The number of command-line arguments.
	- char argv: The command-line arguments.
	- Returns: 0 on successful completion.
	- Code Documentation:

	int main(int argc, char argv) {
		char *file_name;
		t_fdf *fdf;

		if (argc != 2)
			error_by_code(1);	// Check for correct number of arguments

		file_name = argv[1];	// Get the file name from the arguments
		fdf = init_fdf(file_name);	// Initialize the fdf structure

		render(fdf);	// Render the initial scene

		mlx_key_hook(fdf->win, &key_handle, fdf);	// Set the key event handler
		mlx_expose_hook(fdf->win, &key_press_handle, fdf);	// Set the expose event handler
		mlx_loop(fdf->mlx);	// Enter the main loop

		return (0);	// Return 0 to indicate successful completion
	}

File: project.c
This file contains functions for handling different projection modes, such as isometric and perspective, for rendering the 3D map.

Functions:

1. isometric(t_line *line):
	- Purpose: Applies isometric projection to a line.
	- Parameters:
	- t_line *line: The line structure containing the start and end points to project.
	- Code Documentation:

	static void isometric(t_line *line) {
		t_point new_start, new_end;

		// Calculate the new start coordinates using isometric projection
		new_start.x = (line->start.x - line->start.y) * cos(ANG_D_30);
		new_start.y = (line->start.x + line->start.y) * sin(ANG_D_30) - line->start.z;
		line->start.x = new_start.x;
		line->start.y = new_start.y;

		// Calculate the new end coordinates using isometric projection
		new_end.x = (line->end.x - line->end.y) * cos(ANG_D_30);
		new_end.y = (line->end.x + line->end.y) * sin(ANG_D_30) - line->end.z;
		line->end.x = new_end.x;
		line->end.y = new_end.y;
	}


2. perspective(t_line *line):
	- Purpose: Applies perspective projection to a line.
	- Parameters:
	- t_line *line: The line structure containing the start and end points to project.
	- Code Documentation:

	static void perspective(t_line *line) {
		t_point new_start, new_end;
		double z;

		rotate_x(line, 3 * -ANG_D_45);	// Apply rotation around the x-axis

		// Calculate the new start coordinates using perspective projection
		z = line->start.z + line->transform_z;
		new_start.x = line->start.x / z;
		new_start.y = line->start.y / z;
		line->start.x = new_start.x;
		line->start.y = -new_start.y;

		// Calculate the new end coordinates using perspective projection
		z = line->end.z + line->transform_z;
		new_end.x = line->end.x / z;
		new_end.y = line->end.y / z;
		line->end.x = new_end.x;
		line->end.y = -new_end.y;

		scale(line, line->transform_z);	// Scale the line based on the z-transform factor
	}


3. project(t_cam *cam, t_line *line):
	- Purpose: Projects a line based on the current camera projection mode.
	- Parameters:
	- t_cam *cam: The camera structure containing the projection settings.
	- t_line *line: The line structure containing the start and end points to project.
	- Code Documentation:

	void project(t_cam *cam, t_line *line) {
		if (cam->projection == ISOMETRIC)
			isometric(line);	// Apply isometric projection
		else if (cam->projection == PERSPECTIVE)
			perspective(line);	// Apply perspective projection
		else if (cam->projection == TOP)
			return;	// Top view projection does not modify the line
	}


File: read.c


This file contains functions for reading the map data from a file and storing it in a structured format. It handles parsing the file, filling the map's coordinates, and checking the validity of the map.

Functions:

1. get_width(char *file_name):
	- Purpose: Calculates the width (number of columns) of the map by reading the first line of the file and counting the elements.
	- Parameters:
	- char *file_name: The name of the file containing the map data.
	- Returns: The width of the map, or 0 if there is an inconsistency in the number of elements per line.
	- Code Documentation:

	static int get_width(char *file_name) {
		int fd;
		char *line;
		int width, new_width;

		fd = open(file_name, O_RDONLY, 0);	// Open the file for reading
		line = get_next_line(fd);	// Read the first line
		if (!line)
			return (0);	// Return 0 if the file is empty

		width = (int)split_count(line, ' ');	// Calculate the width by counting the elements
		free(line);

		// Iterate through the remaining lines to check for consistency in width
		while (1) {
			line = get_next_line(fd);
			if (line == NULL)
				break;

			new_width = (int)split_count(line, ' ');
			if (width != new_width)
				return (0);	// Return 0 if there is an inconsistency in width

			free(line);
		}

		close(fd);	// Close the file
		return (width);	// Return the calculated width
	}


2. get_depth(char *file_name):
	- Purpose: Calculates the depth (number of rows) of the map by counting the lines in the file.
	- Parameters:
	- char *file_name: The name of the file containing the map data.
	- Returns: The depth of the map.
	- Code Documentation:

	static int get_depth(char *file_name) {
		int fd, depth;
		char *line;

		fd = open(file_name, O_RDONLY, 0);	// Open the file for reading
		depth = 0;

		// Iterate through each line of the file and count non-empty lines
		while (1) {
			line = get_next_line(fd);
			if (line == NULL)
				break;

			if (*line >= 32 && *line <= 126)
				depth++;	// Increment depth for valid lines

			free(line);
		}

		close(fd);	// Close the file
		return (depth);	// Return the calculated depth
	}


3. fill_point(char *point, t_map *map, int coord_x, int coord_y):
	- Purpose: Parses a string representing a point and fills the corresponding coordinate in the map structure.
	- Parameters:
	- char *point: The string representing the point, possibly including a height and color.
	- t_map *map: The map structure where the point will be stored.
	- int coord_x: The x-coordinate in the map.
	- int coord_y: The y-coordinate in the map.
	- Code Documentation:

	static void fill_point(char *point, t_map *map, int coord_x, int coord_y) {
		char info;
		int i;

		map->coordinates[coord_x][coord_y].x = (float)coord_x;	// Set the x-coordinate
		map->coordinates[coord_x][coord_y].y = (float)coord_y;	// Set the y-coordinate

		// Check if the point includes color information
		if (ft_strchr(point, ',')) {
			info = ft_split(point, ',');	// Split the point into height and color
			map->coordinates[coord_x][coord_y].z = (float)ft_atoi(info[0]);	// Set the height (z-coordinate)
			map->coordinates[coord_x][coord_y].color = ft_atoi_base(info[1], "0123456789abcdef");	// Set the color

			i = 0;
			while (info[i])
				free(info[i++]);	// Free the split strings
			free(info);
		} else {
			map->coordinates[coord_x][coord_y].z = (float)ft_atoi(point);	// Set the height if no color is provided
			map->coordinates[coord_x][coord_y].color = -1;	// Set default color
		}

		// Update the map's max and min height (z-coordinate)
		if (map->coordinates[coord_x][coord_y].z > map->max_z)
			map->max_z = map->coordinates[coord_x][coord_y].z;
		if (map->coordinates[coord_x][coord_y].z < map->min_z)
			map->min_z = map->coordinates[coord_x][coord_y].z;
	}


4. get_points(char *file_name, t_map *map):
	- Purpose: Reads the points from the file and fills the map structure with the parsed data.
	- Parameters:
	- char *file_name: The name of the file containing the map data.
	- t_map *map: The map structure to be filled with the parsed points.
	- Code Documentation:

	static void get_points(char *file_name, t_map *map) {
		int fd;
		char *line, split;
		int coord[2];

		fd = open(file_name, O_RDONLY, 0);	// Open the file for reading
		coord[1] = 0;	// Initialize the y-coordinate

		// Iterate through each line of the file
		while (1) {
			line = get_next_line(fd

);
			if (line == NULL)
				break;

			split = ft_split(line, ' ');	// Split the line into individual points
			coord[0] = 0;	// Initialize the x-coordinate

			// Fill each point in the map's coordinates
			while (coord[0] < map->max_x) {
				fill_point(split[coord[0]], map, coord[0], coord[1]);
				free(split[coord[0]]);
				coord[0]++;
			}

			free(split);
			free(line);
			coord[1]++;	// Increment the y-coordinate
		}

		close(fd);	// Close the file
	}


5. read_map(char *file_name):
	- Purpose: Reads the map data from a file and returns a fully populated map structure.
	- Parameters:
	- char *file_name: The name of the file containing the map data.
	- Returns: A pointer to the populated map structure, or NULL on failure.
	- Code Documentation:

	t_map *read_map(char *file_name) {
		t_map *map;
		int fd;

		fd = open(file_name, O_RDONLY, 0);	// Open the file for reading
		if (fd < 0)
			error_by_code(2);	// Handle file reading error

		close(fd);	// Close the file

		map = init_map();	// Initialize the map structure
		if (!map)
			return (NULL);	// Return NULL if initialization fails

		map->max_x = get_width(file_name);	// Get the width of the map
		map->max_y = get_depth(file_name);	// Get the depth of the map
		map->coordinates = init_coordinates(map->max_x, map->max_y);	// Allocate memory for the coordinates

		if (!map->coordinates) {
			free(map);	// Free the map structure if memory allocation fails
			return (NULL);	// Return NULL on failure
		}

		get_points(file_name, map);	// Fill the map with the points from the file
		center_to_origin(map);	// Center the coordinates around the origin

		return (map);	// Return the populated map structure
	}


File: render.c


This file contains the main rendering logic, including functions for drawing the entire map, applying color gradients, and updating the display.

Functions:

1. put_colors(t_fdf *fdf, t_point *point):
	- Purpose: Applies the appropriate color to a point based on its height and the current color settings.
	- Parameters:
	- t_fdf *fdf: The main structure containing camera and color settings.
	- t_point *point: The point structure to which the color will be applied.
	- Code Documentation:

	static void put_colors(t_fdf *fdf, t_point *point) {
		t_color *c = NULL;

		if (fdf->cam->color_pallet == FALSE) {
			if (point->color == -1)
				point->color = LINE_DEFAULT;	// Apply default line color if no color is set
		} else {
			if (point->z >= 0) {
				c = color_pallet_init(C_GREY, C_ORANGY);	// Initialize color gradient for positive heights
				point->color = get_color(c, absolute(point->z), absolute(fdf->map->max_z));
				free(c);
			} else {
				c = color_pallet_init(C_GREY, C_BLUEY);	// Initialize color gradient for negative heights
				point->color = get_color(c, absolute(point->z), absolute(fdf->map->max_z));
				free(c);
			}
		}
	}


2. render_line(t_fdf *fdf, t_point start, t_point end):
	- Purpose: Renders a line between two points, applying all necessary transformations and color adjustments.
	- Parameters:
	- t_fdf *fdf: The main structure containing camera and rendering information.
	- t_point start: The starting point of the line.
	- t_point end: The ending point of the line.
	- Code Documentation:

	static void render_line(t_fdf *fdf, t_point start, t_point end) {
		start.z *= fdf->cam->scale_z;	// Apply z-scale to the start point
		end.z *= fdf->cam->scale_z;	// Apply z-scale to the end point

		put_colors(fdf, &start);	// Apply colors to the start point
		put_colors(fdf, &end);	// Apply colors to the end point

		fdf->image->line = init_line(start, end, fdf);	// Initialize the line structure
		if (!fdf->image->line)
			close_all(fdf, 7);	// Handle error if line initialization fails

		rotate(fdf->cam, fdf->image->line);	// Apply rotation to the line
		project(fdf->cam, fdf->image->line);	// Apply projection to the line
		transform(fdf->cam, fdf->image->line);	// Apply scaling and translation to the line

		bresenham(fdf, fdf->image->line->start, fdf->image->line->end);	// Draw the line using Bresenham's algorithm
		free(fdf->image->line);	// Free the line structure
	}


3. render(t_fdf *fdf):
	- Purpose: Renders the entire map by drawing lines between all adjacent points.
	- Parameters:
	- t_fdf *fdf: The main structure containing map and rendering information.
	- Code Documentation:

	void render(t_fdf *fdf) {
		int x, y;

		clear_image(fdf->image, MAX_PIXEL * 4);	// Clear the image buffer

		// Iterate through the map's coordinates
		y = 0;
		while (y < fdf->map->max_y) {
			x = 0;
			while (x < fdf->map->max_x) {
				if (x < fdf->map->max_x - 1)
					render_line(fdf, fdf->map->coordinates[x][y], fdf->map->coordinates[x + 1][y]);	// Render line to the right neighbor
				if (y < fdf->map->max_y - 1)
					render_line(fdf, fdf->map->coordinates[x][y], fdf->map->coordinates[x][y + 1]);	// Render line to the bottom neighbor
				x++;
			}
			y++;
		}

		mlx_put_image_to_window(fdf->mlx, fdf->win, fdf->image->image, 0, 0);	// Display the image in the window
		print_menu(fdf);	// Display the menu on the screen
	}


File: rotate.c


This file contains functions for rotating lines around the x, y, and z axes.

Functions:

1. rotate_x(t_line *line, double angle):
	- Purpose: Rotates a line around the x-axis by a given angle.
	- Parameters:
	- t_line *line: The line structure containing the start and end points to rotate.
	- double angle: The angle by which to rotate the line around the x-axis.
	- Code Documentation:

	void rotate_x(t_line *line, double angle) {
		t_point new_start, new_end;

		// Calculate the new start coordinates after rotation around the x-axis
		new_start.y = line->start.y * cos(angle) - line->start.z * sin(angle);
		new_start.z = line->start.y * sin(angle) + line->start.z * cos(angle);
		line->start.y = new_start.y;
		line->start.z = new_start.z;

		// Calculate the new end coordinates after rotation around the x-axis
		new_end.y = line->end.y * cos(angle) - line->end.z * sin(angle);
		new_end.z = line->end.y * sin(angle) + line->end.z * cos(angle);
		line->end.y = new_end.y;
		line->end.z = new_end.z;
	}


2. rotate_y(t_line *line, double angle):
	- Purpose: Rotates a line around the y-axis by a given angle.
	- Parameters:
	- t_line *line: The line structure containing the start and end points to rotate.
	- double angle: The angle by which to rotate the line around the y-axis.
	- Code Documentation:

	void rotate_y(t_line *line, double angle) {
		t_point new_start, new_end;

		// Calculate the new start coordinates after rotation around the y-axis
		new_start.x = line->start.x * cos(angle) - line->start.z * sin(angle);
		new_start.z = line->start.x * sin(angle) + line->start.z * cos(angle);
		line->start.x = new_start.x;
		line->start.z = new_start.z;

		//

 Calculate the new end coordinates after rotation around the y-axis
		new_end.x = line->end.x * cos(angle) - line->end.z * sin(angle);
		new_end.z = line->end.x * sin(angle) + line->end.z * cos(angle);
		line->end.x = new_end.x;
		line->end.z = new_end.z;
	}


3. rotate_z(t_line *line, double angle):
	- Purpose: Rotates a line around the z-axis by a given angle.
	- Parameters:
	- t_line *line: The line structure containing the start and end points to rotate.
	- double angle: The angle by which to rotate the line around the z-axis.
	- Code Documentation:

	void rotate_z(t_line *line, double angle) {
		t_point new_start, new_end;

		// Calculate the new start coordinates after rotation around the z-axis
		new_start.x = line->start.x * cos(angle) - line->start.y * sin(angle);
		new_start.y = line->start.x * sin(angle) + line->start.y * cos(angle);
		line->start.x = new_start.x;
		line->start.y = new_start.y;

		// Calculate the new end coordinates after rotation around the z-axis
		new_end.x = line->end.x * cos(angle) - line->end.y * sin(angle);
		new_end.y = line->end.x * sin(angle) + line->end.y * cos(angle);
		line->end.x = new_end.x;
		line->end.y = new_end.y;
	}


4. rotate(t_cam *cam, t_line *line):
	- Purpose: Rotates a line based on the camera's current rotation angles around the x, y, and z axes.
	- Parameters:
	- t_cam *cam: The camera structure containing the rotation angles.
	- t_line *line: The line structure containing the start and end points to rotate.
	- Code Documentation:

	void rotate(t_cam *cam, t_line *line) {
		rotate_x(line, cam->alpha);	// Rotate the line around the x-axis
		rotate_y(line, cam->beta);	// Rotate the line around the y-axis
		rotate_z(line, cam->gamma);	// Rotate the line around the z-axis
	}


File: transform.c


This file contains functions for transforming lines, including scaling and translating, to fit them within the viewing window.

Functions:

1. scale(t_line *line, int scale_factor):
	- Purpose: Scales a line by a given factor.
	- Parameters:
	- t_line *line: The line structure containing the start and end points to scale.
	- int scale_factor: The factor by which to scale the line.
	- Code Documentation:

	void scale(t_line *line, int scale_factor) {
		line->start.x *= scale_factor;	// Scale the x-coordinate of the start point
		line->start.y *= scale_factor;	// Scale the y-coordinate of the start point
		line->end.x *= scale_factor;	// Scale the x-coordinate of the end point
		line->end.y *= scale_factor;	// Scale the y-coordinate of the end point
	}


2. translate(t_line *line, int move_x, int move_y):
	- Purpose: Translates (moves) a line by a given amount in the x and y directions.
	- Parameters:
	- t_line *line: The line structure containing the start and end points to translate.
	- int move_x: The amount to move the line in the x direction.
	- int move_y: The amount to move the line in the y direction.
	- Code Documentation:

	void translate(t_line *line, int move_x, int move_y) {
		line->start.x += move_x;	// Translate the x-coordinate of the start point
		line->start.y += move_y;	// Translate the y-coordinate of the start point
		line->end.x += move_x;	// Translate the x-coordinate of the end point
		line->end.y += move_y;	// Translate the y-coordinate of the end point
	}


3. transform(t_cam *cam, t_line *line):
	- Purpose: Applies scaling and translation transformations to a line based on the camera settings.
	- Parameters:
	- t_cam *cam: The camera structure containing the scaling and translation settings.
	- t_line *line: The line structure containing the start and end points to transform.
	- Code Documentation:

	void transform(t_cam *cam, t_line *line) {
		scale(line, cam->scale_factor);	// Scale the line based on the camera's scale factor
		translate(line, cam->move_x, cam->move_y);	// Translate the line based on the camera's position
	}

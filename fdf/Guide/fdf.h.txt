File: fdf.h
This is the main header file for the fdf project, containing all the necessary includes, macro definitions, enumerations, and type
definitions used throughout the program. It also declares all the functions used in the project.

Includes:

# include <stdlib.h>			// Standard library functions (e.g., malloc, free)
# include <unistd.h>			// Unix standard functions (e.g., read, write)
# include <fcntl.h>				// File control options (e.g., open)
# include <math.h>				// Math functions (e.g., cos, sin)
# include "../minilibx/mlx.h" 	// MiniLibX for graphical interface
# include "libft.h"				// Custom C library functions
# include "get_next_line.h"		// Function to read lines from a file
# include "keys.h"				// Definitions of keycodes used in the program
# include "colors.h"			// Definitions of color codes

Macro Definitions:

- Window and Image Settings:
# define WINDOW_NAME			"fdf"		// Title of the window
# define WINDOW_WIDTH			1200		// Width of the window in pixels
# define WINDOW_HEIGHT			900			// Height of the window in pixels
# define MAX_PIXEL				1080000		// Maximum number of pixels in the image (1200 * 900)

- Colors Configuration:
# define LINE_DEFAULT				C_WHITE		// Default line color (white)
# define BACKGROUND_DEFAULT		C_GREY		// Default background color (grey)
# define C_TEXT					C_WHITE		// Default text color (white)

- Conversion Bases & Useful Angles:
# define HEXADECIMAL_L_BASE		"0123456789abcdef"	// Hexadecimal base for conversions
# define ANG_D_1				0.01745329	// 1 degree in radians
# define ANG_D_30					0.52359877	// 30 degrees in radians
# define ANG_D_45					0.78539816	// 45 degrees in radians

Enumerations:

- e_projection: Enumerator for the different projection modes.
enum e_projection
{
	ISOMETRIC,	// Isometric projection
	PERSPECTIVE,	// Perspective projection
	TOP			// Top-down view projection
};

- e_bool: Enumerator for boolean values.
enum e_bool
{
	FALSE,		// Boolean false (0)
	TRUE		// Boolean true (1)
};

Type Definitions:

- t_point:  structure used to represent a single point in 3D space. This includes its position in 3D (x, y, z) and its color.
	- 3D Coordinates: By storing x, y, and z as floats, the structure can represent the precise location of a point in 3D space.
	- Color: Inclusion of a color property allows for each point to have an associated color, which is necessary for rendering
					colored images or gradients.
typedef struct s_point
{
	float	x;	// X coordinate
	float	y;	// Y coordinate
	float	z;	// Z coordinate (height)
	int		color; // Color of the point
} t_point;

- t_map: structure representing the entire map or grid of points that make up the 3D model. It organizes these points and stores
		metadata about the map, such as its dimensions and the range of its z-values.
		- 2D Array of Points: The coordinates field as a 2D array allows the program to easily access any point on the map by
				its x and y indices.
		- Map Dimensions: The max and min values for x, y, and z provide important information about the scale and bounds of themap.
typedef struct s_map
{
	t_point **coordinates;	// 2D array of points (map coordinates)
	int	max_x;				// Maximum X value (width of the map)
	int	max_y;				// Maximum Y value (height of the map)
	int	max_z;				// Maximum Z value (height of the map)
	int	min_z;				// Minimum Z value (depth of the map)
} t_map;

- t_line: structure representing a line segment in 3D space, defined by a starting point and an ending point. The additional transform_z
		is used for perspective transformations.
		- Starting and Ending Points: By explicitly defining the start and end points as t_point structures, the program can perform
				operations like rendering, scaling, and transforming lines with ease.
		- Perspective Projection: The transform_z value is necessary for perspective projections, which involve transforming the z-coordinate
				to simulate depth on a 2D plane.
typedef struct s_line
{
	t_point	start;			// Starting point of the line
	t_point	end;			// Ending point of the line
	float	transform_z;	// Z transformation value for perspective projection
} t_line;

- t_color: structure used to handle color gradients, which are transitions between two colors. It stores both the starting and ending
		colors, as well as the differences between their components
		- Color Gradients: By storing the start and end colors and their RGB components separately, this structure enables smooth color transitions.
		- Delta Values: The differences (deltas) between the color components allow for easy calculation of intermediate colors, facilitating gradient rendering.
typedef struct s_color
{
	int	start_color;	// Starting color
	int	start_r;		// Red component of the starting color
	int	start_g;		// Green component of the starting color
	int	start_b;		// Blue component of the starting color
	int	end_color;		// Ending color
	int	end_r;			// Red component of the ending color
	int	end_g;			// Green component of the ending color
	int	end_b;			// Blue component of the ending color
	int	delta_r;		// Difference in red component between start and end colors
	int	delta_g;		// Difference in green component between start and end colors
	int	delta_b;		// Difference in blue component between start and end colors
} t_color;


- t_image: structure holding information about an image that is being generated or displayed by the program.
		- Image Buffer: The buffer is where pixel data is stored, and itâ€™s crucial for directly manipulating
				the image that will be displayed on the screen.
		- Line Rendering: The inclusion of a t_line pointer allows for easy access to the current line being
				rendered, making it efficient to draw and update the image.
typedef struct s_image
{
	void	*image;		// Image pointer
	int	pixel_bits;		// Number of bits per pixel
	int	line_bytes;		// Number of bytes per line
	int	endian;			// Endianness of the image
	char	*buffer;	// Pointer to the image buffer
	t_line	*line;		// Pointer to the current line being rendered
} t_image;


- t_cam: structure representing the camera settings in the program. It defines how the 3D model is viewed, including
		its projection mode, scale, translation (panning), and rotation.
		- Projection and View Control: The projection mode and rotation angles (alpha, beta, gamma) allow for various
				ways to view and manipulate the 3D model, essential for creating dynamic visualizations.
		- Panning and Zooming: The scale factors and translation values enable zooming and moving the camera, providing
				control over how the model is displayed on the screen.
		- Color Pallet Toggle: This allows the user to switch between different color schemes or gradients, enhancing
				the visual representation.
typedef struct s_cam
	{
	int		projection;			// Current projection mode (e.g., ISOMETRIC)
	int		color_pallet;		// Boolean to toggle color pallet
	float	scale_factor;		// Scale factor for zooming
	float	scale_z;			// Z-axis scale factor
	float	move_x;				// X-axis translation (panning)
	float	move_y;				// Y-axis translation (panning)
	double	alpha;				// Rotation angle around X-axis
	double	beta;				// Rotation angle around Y-axis
	double	gamma;				// Rotation angle around Z-axis
} t_cam;


- t_fdf: Main structure structure encapsulates the entire state of the fdf program, holding pointers to all major components
		like the map, the image being rendered, the camera settings, and the MLX instance.
		- Centralized Control: By encapsulating everything in t_fdf, the program can easily manage and pass around the state,
				ensuring that all components (map, image, camera) are coordinated during operations like rendering.
		- Modularity: Each component (map, image, camera) is represented by its own structure, which simplifies the program's
				design and makes the codebase more modular and easier to maintain or extend.
		- MLX Integration: Including the MLX instance and window within this structure ties the rendering loop and event handling
				directly to the data that controls the visualization, making the program more cohesive and easier to manage.
typedef struct s_fdf
{
	t_map		*map;			// Pointer to the map structure
	void		*mlx;			// Pointer to the MLX instance
	int		win_x;		// Window width
	int		win_y;		// Window height
	void		*win;			// Pointer to the window
	t_image	*image;		// Pointer to the image structure
	t_cam		*cam;			// Pointer to the camera structure
} t_fdf;


Function Prototypes:

- Mathematical Utilities:
float get_min(float a, float b);			// Returns the minimum of two floats
float get_max(float a, float b);			// Returns the maximum of two floats
float absolute(float n);				// Returns the absolute value of a float


- Transformations:
void transform(t_cam *cam, t_line *line);					// Applies transformations to a line based on camera settings
void translate(t_line *line, int move_x, int move_y);		// Translates a line by given x and y values
void scale(t_line *line, int scale_factor);					// Scales a line by a given factor
void rotate(t_cam *cam, t_line *line);						// Rotates a line based on camera angles
void rotate_x(t_line *line, double angle);					// Rotates a line around the X-axis
void rotate_y(t_line *line, double angle);					// Rotates a line around the Y-axis
void rotate_z(t_line *line, double angle);					// Rotates a line around the Z-axis


- Rendering and Display:
void render(t_fdf *fdf);						// Renders the entire map
t_map *read_map(char *file_name);				// Reads and parses the map from a file
void project(t_cam *cam, t_line *line);			// Projects a line based on the current projection mode
void print_menu(t_fdf *fdf);					// Displays the on-screen menu


- Initialization:
t_line	*init_line(t_point start, t_point end, t_fdf *fdf);			// Initializes a line structure
t_cam	*init_cam(t_map *map);										// Initializes the camera settings
t_image	*init_image(void *mlx);										// Initializes the image structure
t_map	*init_map(void);											// Initializes the map structure
t_fdf	*init_fdf(char *file_name);									// Initializes the main fdf structure
void	reset(t_fdf *fdf);											// Resets the camera and rendering settings
float	scale_to_fit(t_map *map);									// Calculates the scale factor to fit the map in the window
void	center_to_origin(t_map *map);								// Centers the map coordinates around the origin
t_point	init_coordinates(int width, int depth);						// Initializes the map's coordinate array


- Error Handling:
void error_by_code(int exit_code);				// Handles errors and exits the program with a message


- Drawing Utilities:
void bresenham(t_fdf *fdf, t_point start, t_point end);  // Draws a line using the Bresenham algorithm
void pixels_to_image(t_image *image, float x, float y, int color); // Draws a pixel to the image buffer
void clear_image(t_image *image, int image_size); // Clears the image buffer


- Color Utilities:
int get_color(t_color *color, int i_line, int line_size); // Gets the color at a specific point along a gradient
t_color *color_init(t_point start, t_point end); // Initializes a color structure based on two points
t_color *color_pallet_init(int min_color, int max_color); // Initializes a color gradient


- Closing and Exiting:
void close_all(t_fdf *fdf, int exit_code);	// Closes all resources and exits the program
void close_map(t_fdf *fdf, int exit_code);	// Closes the map and associated resources


- String and File Utilities:
int ft_atoi_base(char *str, char *base);		// Converts a string to an integer based on a given base
size_t split_count(const char *s, char c);	// Counts the number of splits in a string based on a delimiter




File: draw.c


This file contains the functions responsible for drawing lines on the screen using the Bresenham algorithm, as well as functions for managing the image buffer.

Functions:

1. bresenham(t_fdf *fdf, t_point start, t_point end):
	- Purpose: Draws a line between two points using the Bresenham algorithm.
	- Parameters:
	- t_fdf *fdf: The main structure containing image and rendering information.
	- t_point start: The starting point of the line.
	- t_point end: The ending point of the line.
	- Code Documentation:

	void bresenham(t_fdf *fdf, t_point start, t_point end) {
		float x_step, y_step;
		int max_steps;
		int i_line;
		t_color *color;

		x_step = end.x - start.x;	// Calculate the difference in x
		y_step = end.y - start.y;	// Calculate the difference in y
		max_steps = (int)get_max(absolute(x_step), absolute(y_step));	// Determine the number of steps based on the greater difference

		x_step /= max_steps;	// Normalize the x_step
		y_step /= max_steps;	// Normalize the y_step

		color = color_init(start, end);	// Initialize color gradient between the start and end points
		if (!color)
			close_all(fdf, 8);	// Handle error if color initialization fails

		i_line = 0;
		while (i_line < max_steps) {
			start.color = get_color(color, i_line++, max_steps);	// Get the current color based on progress
			if (start.x > 0 && start.y > 0 && start.x < WINDOW_WIDTH && start.y < WINDOW_HEIGHT)
				pixels_to_image(fdf->image, start.x, start.y, start.color);	// Draw the pixel in the image buffer

			start.x += x_step;	// Increment x position
			start.y += y_step;	// Increment y position
		}
		free(color);	// Free the color structure
	}


2. pixels_to_image(t_image *image, float x, float y, int color):
	- Purpose: Draws a pixel in the image buffer at the specified coordinates.
	- Parameters:
	- t_image *image: The image structure containing the buffer.
	- float x: The x-coordinate of the pixel.
	- float y: The y-coordinate of the pixel.
	- int color: The color of the pixel.
	- Code Documentation:

	void pixels_to_image(t_image *image, float x, float y, int color) {
		int pixel;

		pixel = ((int)y * image->line_bytes) + ((int)x * 4);	// Calculate the pixel's position in the buffer

		// Handle endian-ness when writing the color to the buffer
		if (image->endian == 1) {
			image->buffer[pixel + 0] = (color >> 24);		// Write red channel
			image->buffer[pixel + 1] = (color >> 16) & 0xff;	// Write green channel
			image->buffer[pixel + 2] = (color >> 8) & 0xff;	// Write blue channel
			image->buffer[pixel + 3] = (color) & 0xff;		// Write alpha channel
		}
		else if (image->endian == 0) {
			image->buffer[pixel + 0] = (color) & 0xff;		// Write alpha channel
			image->buffer[pixel + 1] = (color >> 8) & 0xff;	// Write blue channel
			image->buffer[pixel + 2] = (color >> 16) & 0xff;	// Write green channel
			image->buffer[pixel + 3] = (color >> 24);		// Write red channel
		}
	}


3. clear_image(t_image *image, int image_size):
	- Purpose: Clears the image buffer by setting it to a default background color.
	- Parameters:
	- t_image *image: The image structure containing the buffer.
	- int image_size: The size of the image buffer.
	- Code Documentation:

	void clear_image(t_image *image, int image_size) {
		int x, y;

		ft_bzero(image->buffer, image_size);	// Clear the buffer

		// Fill the buffer

 with the default background color
		y = 0;
		while (y < WINDOW_HEIGHT) {
			x = 0;
			while (x < WINDOW_WIDTH) {
				pixels_to_image(image, x, y, BACKGROUND_DEFAULT);	// Set each pixel to the background color
				x++;
			}
			y++;
		}
	}

File: main.c
This file contains the entry point (main function) of the program and sets up the main loop for rendering and handling events.

Functions:

1. key_press_handle(t_fdf *fdf):
	- Purpose: Handles the expose event (when the window needs to be redrawn).
	- Parameters:
	- t_fdf *fdf: The main structure containing rendering information.
	- Returns: 0 after handling the event.
	- Code Documentation:

	static int key_press_handle(t_fdf *fdf) {
		render(fdf);	// Re-render the scene when the window is exposed
		return (0);	// Return 0 to indicate successful handling
	}


2. main(int argc, char argv):
	- Purpose: The entry point of the program. Initializes the program, processes input, and enters the main event loop.
	- Parameters:
	- int argc: The number of command-line arguments.
	- char argv: The command-line arguments.
	- Returns: 0 on successful completion.
	- Code Documentation:

	int main(int argc, char argv) {
		char *file_name;
		t_fdf *fdf;

		if (argc != 2)
			error_by_code(1);	// Check for correct number of arguments

		file_name = argv[1];	// Get the file name from the arguments
		fdf = init_fdf(file_name);	// Initialize the fdf structure

		render(fdf);	// Render the initial scene

		mlx_key_hook(fdf->win, &key_handle, fdf);	// Set the key event handler
		mlx_expose_hook(fdf->win, &key_press_handle, fdf);	// Set the expose event handler
		mlx_loop(fdf->mlx);	// Enter the main loop

		return (0);	// Return 0 to indicate successful completion
	}

File: render.c


This file contains the main rendering logic, including functions for drawing the entire map, applying color gradients, and updating the display.

Functions:

1. put_colors(t_fdf *fdf, t_point *point):
	- Purpose: Applies the appropriate color to a point based on its height and the current color settings.
	- Parameters:
	- t_fdf *fdf: The main structure containing camera and color settings.
	- t_point *point: The point structure to which the color will be applied.
	- Code Documentation:

	static void put_colors(t_fdf *fdf, t_point *point) {
		t_color *c = NULL;

		if (fdf->cam->color_pallet == FALSE) {
			if (point->color == -1)
				point->color = LINE_DEFAULT;	// Apply default line color if no color is set
		} else {
			if (point->z >= 0) {
				c = color_pallet_init(C_GREY, C_ORANGE);	// Initialize color gradient for positive heights
				point->color = get_color(c, absolute(point->z), absolute(fdf->map->max_z));
				free(c);
			} else {
				c = color_pallet_init(C_GREY, C_BLUEY);	// Initialize color gradient for negative heights
				point->color = get_color(c, absolute(point->z), absolute(fdf->map->max_z));
				free(c);
			}
		}
	}


2. render_line(t_fdf *fdf, t_point start, t_point end):
	- Purpose: Renders a line between two points, applying all necessary transformations and color adjustments.
	- Parameters:
	- t_fdf *fdf: The main structure containing camera and rendering information.
	- t_point start: The starting point of the line.
	- t_point end: The ending point of the line.
	- Code Documentation:

	static void render_line(t_fdf *fdf, t_point start, t_point end) {
		start.z *= fdf->cam->scale_z;	// Apply z-scale to the start point
		end.z *= fdf->cam->scale_z;	// Apply z-scale to the end point

		put_colors(fdf, &start);	// Apply colors to the start point
		put_colors(fdf, &end);	// Apply colors to the end point

		fdf->image->line = init_line(start, end, fdf);	// Initialize the line structure
		if (!fdf->image->line)
			close_all(fdf, 7);	// Handle error if line initialization fails

		rotate(fdf->cam, fdf->image->line);	// Apply rotation to the line
		project(fdf->cam, fdf->image->line);	// Apply projection to the line
		transform(fdf->cam, fdf->image->line);	// Apply scaling and translation to the line

		bresenham(fdf, fdf->image->line->start, fdf->image->line->end);	// Draw the line using Bresenham's algorithm
		free(fdf->image->line);	// Free the line structure
	}


3. render(t_fdf *fdf):
	- Purpose: Renders the entire map by drawing lines between all adjacent points.
	- Parameters:
	- t_fdf *fdf: The main structure containing map and rendering information.
	- Code Documentation:

	void render(t_fdf *fdf) {
		int x, y;

		clear_image(fdf->image, MAX_PIXEL * 4);	// Clear the image buffer

		// Iterate through the map's coordinates
		y = 0;
		while (y < fdf->map->max_y) {
			x = 0;
			while (x < fdf->map->max_x) {
				if (x < fdf->map->max_x - 1)
					render_line(fdf, fdf->map->coordinates[x][y], fdf->map->coordinates[x + 1][y]);	// Render line to the right neighbor
				if (y < fdf->map->max_y - 1)
					render_line(fdf, fdf->map->coordinates[x][y], fdf->map->coordinates[x][y + 1]);	// Render line to the bottom neighbor
				x++;
			}
			y++;
		}

		mlx_put_image_to_window(fdf->mlx, fdf->win, fdf->image->image, 0, 0);	// Display the image in the window
		print_menu(fdf);	// Display the menu on the screen
	}


File: rotate.c


This file contains functions for rotating lines around the x, y, and z axes.

Functions:

1. rotate_x(t_line *line, double angle):
	- Purpose: Rotates a line around the x-axis by a given angle.
	- Parameters:
	- t_line *line: The line structure containing the start and end points to rotate.
	- double angle: The angle by which to rotate the line around the x-axis.
	- Code Documentation:

	void rotate_x(t_line *line, double angle) {
		t_point new_start, new_end;

		// Calculate the new start coordinates after rotation around the x-axis
		new_start.y = line->start.y * cos(angle) - line->start.z * sin(angle);
		new_start.z = line->start.y * sin(angle) + line->start.z * cos(angle);
		line->start.y = new_start.y;
		line->start.z = new_start.z;

		// Calculate the new end coordinates after rotation around the x-axis
		new_end.y = line->end.y * cos(angle) - line->end.z * sin(angle);
		new_end.z = line->end.y * sin(angle) + line->end.z * cos(angle);
		line->end.y = new_end.y;
		line->end.z = new_end.z;
	}


2. rotate_y(t_line *line, double angle):
	- Purpose: Rotates a line around the y-axis by a given angle.
	- Parameters:
	- t_line *line: The line structure containing the start and end points to rotate.
	- double angle: The angle by which to rotate the line around the y-axis.
	- Code Documentation:

	void rotate_y(t_line *line, double angle) {
		t_point new_start, new_end;

		// Calculate the new start coordinates after rotation around the y-axis
		new_start.x = line->start.x * cos(angle) - line->start.z * sin(angle);
		new_start.z = line->start.x * sin(angle) + line->start.z * cos(angle);
		line->start.x = new_start.x;
		line->start.z = new_start.z;

		//

 Calculate the new end coordinates after rotation around the y-axis
		new_end.x = line->end.x * cos(angle) - line->end.z * sin(angle);
		new_end.z = line->end.x * sin(angle) + line->end.z * cos(angle);
		line->end.x = new_end.x;
		line->end.z = new_end.z;
	}


3. rotate_z(t_line *line, double angle):
	- Purpose: Rotates a line around the z-axis by a given angle.
	- Parameters:
	- t_line *line: The line structure containing the start and end points to rotate.
	- double angle: The angle by which to rotate the line around the z-axis.
	- Code Documentation:

	void rotate_z(t_line *line, double angle) {
		t_point new_start, new_end;

		// Calculate the new start coordinates after rotation around the z-axis
		new_start.x = line->start.x * cos(angle) - line->start.y * sin(angle);
		new_start.y = line->start.x * sin(angle) + line->start.y * cos(angle);
		line->start.x = new_start.x;
		line->start.y = new_start.y;

		// Calculate the new end coordinates after rotation around the z-axis
		new_end.x = line->end.x * cos(angle) - line->end.y * sin(angle);
		new_end.y = line->end.x * sin(angle) + line->end.y * cos(angle);
		line->end.x = new_end.x;
		line->end.y = new_end.y;
	}


4. rotate(t_cam *cam, t_line *line):
	- Purpose: Rotates a line based on the camera's current rotation angles around the x, y, and z axes.
	- Parameters:
	- t_cam *cam: The camera structure containing the rotation angles.
	- t_line *line: The line structure containing the start and end points to rotate.
	- Code Documentation:

	void rotate(t_cam *cam, t_line *line) {
		rotate_x(line, cam->alpha);	// Rotate the line around the x-axis
		rotate_y(line, cam->beta);	// Rotate the line around the y-axis
		rotate_z(line, cam->gamma);	// Rotate the line around the z-axis
	}


File: transform.c


This file contains functions for transforming lines, including scaling and translating, to fit them within the viewing window.

Functions:

1. scale(t_line *line, int scale_factor):
	- Purpose: Scales a line by a given factor.
	- Parameters:
	- t_line *line: The line structure containing the start and end points to scale.
	- int scale_factor: The factor by which to scale the line.
	- Code Documentation:

	void scale(t_line *line, int scale_factor) {
		line->start.x *= scale_factor;	// Scale the x-coordinate of the start point
		line->start.y *= scale_factor;	// Scale the y-coordinate of the start point
		line->end.x *= scale_factor;	// Scale the x-coordinate of the end point
		line->end.y *= scale_factor;	// Scale the y-coordinate of the end point
	}


2. translate(t_line *line, int move_x, int move_y):
	- Purpose: Translates (moves) a line by a given amount in the x and y directions.
	- Parameters:
	- t_line *line: The line structure containing the start and end points to translate.
	- int move_x: The amount to move the line in the x direction.
	- int move_y: The amount to move the line in the y direction.
	- Code Documentation:

	void translate(t_line *line, int move_x, int move_y) {
		line->start.x += move_x;	// Translate the x-coordinate of the start point
		line->start.y += move_y;	// Translate the y-coordinate of the start point
		line->end.x += move_x;	// Translate the x-coordinate of the end point
		line->end.y += move_y;	// Translate the y-coordinate of the end point
	}


3. transform(t_cam *cam, t_line *line):
	- Purpose: Applies scaling and translation transformations to a line based on the camera settings.
	- Parameters:
	- t_cam *cam: The camera structure containing the scaling and translation settings.
	- t_line *line: The line structure containing the start and end points to transform.
	- Code Documentation:

	void transform(t_cam *cam, t_line *line) {
		scale(line, cam->scale_factor);	// Scale the line based on the camera's scale factor
		translate(line, cam->move_x, cam->move_y);	// Translate the line based on the camera's position
	}

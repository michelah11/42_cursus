1. Color Gradients
A color gradient is a gradual transition between two colors. In computer graphics, when you need to visually
represent a smooth transition from one color to another (such as shading, backgrounds, or lines), this gradient
is calculated by interpolating between the RGB values of the start and end colors. Gradients are frequently used
in 2D and 3D rendering to make visuals more appealing by avoiding harsh color boundaries.

    - Linear Gradient: In this form, the transition between colors is uniform across a line or surface. For example,
    if you want a line to start as red and end as blue, the color at each point along the line is determined based
    on how far along the line you are.

    - Non-Linear Gradients: These may use a non-uniform progression to create effects like easing in or easing out
    (used often in animation).

In the context of the color.c file, the function calculates a linear gradient based on the "progress" value, which
ranges from 0.0 (start color) to 1.0 (end color). At each point along the line, this progress value is used to blend
the color components (red, green, blue).

For example, if we want to blend from pure red (#FF0000) to pure blue (#0000FF):

At the start (progress = 0), the color is red.
At the halfway point (progress = 0.5), the color is purple, a mix of red and blue.
At the end (progress = 1), the color is blue.

2. RGB Color Model
In the RGB color model, colors are created by combining three primary colors:
R: Red
G: Green
B: Blue

Each color component can take values from 0 to 255. For example:
Red is represented as (255, 0, 0) (maximum red, no green or blue).
Green is (0, 255, 0).
Blue is (0, 0, 255).
When all values are set to zero (0, 0, 0), the color is black. When all are set to their maximum value (255, 255, 255),
the color is white. By adjusting these values, you can create any color.

2.1. Packed 32-bit RGB Integer Representation:
In computer graphics, colors are often represented as a single 32-bit integer, with 8 bits (1 byte) dedicated to each of the
three primary colors. Sometimes, an extra 8 bits are used for an alpha channel (opacity), but in simple RGB representations,
only 24 bits are used:
    - The most significant 8 bits store the red value.
    - The next 8 bits store the green value.
    - The least significant 8 bits store the blue value.

This is commonly represented as: 0xRRGGBB
Where:
RR is the red value (in hexadecimal format),
GG is the green value, and
BB is the blue value.

For example, the color white is represented as: 0xFFFFFF  // (255, 255, 255)
To convert individual R, G, and B components into a packed color, you use bitwise shifting: int color = (red << 16) + (green << 8) + blue;
Where:
    - red << 16 shifts the red component 16 bits to the left to occupy the correct position.
    - green << 8 shifts the green component 8 bits to the left.
    - blue stays in the least significant 8 bits.

3. Bitwise Operations
Bitwise operations allow us to manipulate individual bits within integers. These operations are crucial when packing or extracting
RGB values from a 32-bit integer.

Common Bitwise Operations:
Bitwise AND (&): This is used to mask specific bits in a number. For example:
    int red = (color & 0xFF0000) >> 16;
0xFF0000 is a mask that isolates the red portion of the color, setting all other bits to zero.
The result is then shifted 16 bits to the right to align the red value with the least significant bits, making it an integer between 0 and 255.

Bitwise Shift (>> and <<): These shift the bits of a number to the left or right. This is useful for placing RGB components in the correct positions:
    >>: Right shift, which moves bits to the right, effectively dividing the number by powers of two.
    <<: Left shift, which moves bits to the left, multiplying the number by powers of two.

For instance:
int red = (color & 0xFF0000) >> 16;  // Extract the red component
int green = (color & 0x00FF00) >> 8; // Extract the green component
int blue = color & 0x0000FF;         // Extract the blue component
These operations allow us to work with the packed integer representation of colors by isolating and manipulating each component individually.

4. Delta Values
In color gradients, delta values are used to define the difference between the RGB components of two colors (start and end colors). The idea is to calculate the rate of change for each RGB channel, so you know how much each component should change as you move along the gradient.

Formula for Deltas:
delta_r = end_red - start_red;
delta_g = end_green - start_green;
delta_b = end_blue - start_blue;

The deltas tell us:
How much the red component should change between the start and end colors.
How much the green component should change between the start and end colors.
How much the blue component should change between the start and end colors.
Example:
Letâ€™s say you want to create a gradient between two colors:

Start color: Red (255, 0, 0).
End color: Blue (0, 0, 255).

Here are the deltas:
delta_r = 0 - 255 = -255;   // Red will decrease by 255 units
delta_g = 0 - 0 = 0;        // Green will stay the same
delta_b = 255 - 0 = 255;    // Blue will increase by 255 units

As we move along the gradient, we can apply the deltas based on the progress (from 0 to 1). If the progress is halfway (i.e., 0.5), we adjust the color components by applying half of the deltas:
red = start_red + (delta_r * progress);
green = start_green + (delta_g * progress);
blue = start_blue + (delta_b * progress);

At progress = 0.5:
red = 255 + (-255 * 0.5) = 127;   // Halfway between red and blue
green = 0 + (0 * 0.5) = 0;        // No change in green
blue = 0 + (255 * 0.5) = 127;     // Halfway between red and blue
At this point, the color is purple (127, 0, 127), which is a mix of red and blue.

5. Interpolation in Gradients
Interpolation is the process of calculating intermediate values between two endpoints. In the context of color gradients, interpolation refers to the blending of the start and end color components (red, green, and blue) based on the progress value.

For linear interpolation, the formula is:
value = start_value + (delta_value * progress);
This interpolation ensures a smooth transition between the two colors across the gradient, with progress determining how far along the gradient you are.




File: color.c

This file handles color gradients and color initialization for drawing in the program.

Functions:

1. color_gradient(t_color *color, float progress):
    - Purpose: Computes the color based on the progress value, which determines how far
        along the gradient you are.
    - Parameters:
        - t_color *color: The structure holding color information and deltas.
        - float progress: A value between 0 and 1 representing the progress.
    - Returns: The computed color.
    -- For each RGB component (red, green, blue), it calculates the current value based on the delta
        and the progress.
    -- r, g, and b are computed using the deltas and progress and then packed back into a single
        integer, which represents the final color.
    - Code Documentation:

    static int color_gradient(t_color *color, float progress)
    {
        int r, g, b;

        r = color->delta_r * progress;    // Calculate red channel gradient
        if (r < -255) r = 0;
        else if (r > 255) r = 255;
        r = r << 16;    // Shift red to its correct position in the color integer

        g = color->delta_g * progress;    // Calculate green channel gradient
        if (g < -255) g = 0;
        else if (g > 255) g = 255;
        g = g << 8;    // Shift green to its correct position

        b = color->delta_b * progress;    // Calculate blue channel gradient
        if (b < -255) b = 0;
        else if (b > 255) b = 255;

        return (color->start_color + r + g + b);    // Combine the channels to get the final color
    }


2. get_color(t_color *color, int i_line, int line_size):
    - Purpose: Gets a color based on the position along a line.
    - Parameters:
        - t_color *color: The structure holding color gradient information.
        - int i_line: The current position along the line.
        - int line_size: The total length of the line.
    - Returns: The color at the given position.
    -- progress is calculated by dividing the current position by the total line size, which gives a
        value between 0 and 1.
    -- color_gradient is then called with this progress value to get the color at that specific point.
    - Code Documentation:

    int get_color(t_color *color, int i_line, int line_size)
    {
        float progress = (float) i_line / (float) line_size;    // Calculate the progress as a fraction
        return color_gradient(color, progress);    // Get the color based on the progress
    }


3. color_init(t_point start, t_point end):
    - Purpose:  Initializes the t_color structure to manage a gradient between two points (start
            and end), calculating the necessary delta values for the gradient
    - Parameters:
    - t_point start: The starting point of the gradient.
    - t_point end: The ending point of the gradient.
    - Returns: A pointer to the initialized t_color structure, or NULL on failure.
    -- Extracts the RGB values from the start and end colors.
    -- Computes the deltas (delta_r, delta_g, delta_b) by subtracting the RGB values of the start
        point from the end point. These deltas represent how much each color component changes across the gradient.
    - Code Documentation:

    t_color *color_init(t_point start, t_point end)
    {
        t_color *color;

        color = malloc(sizeof(t_color));    // Allocate memory for the color structure
        if (!color)
            return (NULL);    // Return NULL if allocation fails
        color->start_color = start.color;    // Initialize start color
        color->start_r = (C_RED & start.color) >> 16;    // Extract red component
        color->start_g = (C_GREEN & start.color) >> 8;    // Extract green component
        color->start_b = (C_BLUE & start.color);    // Extract blue component
        color->end_color = end.color;    // Initialize end color
        color->end_r = (C_RED & end.color) >> 16;
        color->end_g = (C_GREEN & end.color) >> 8;
        color->end_b = (C_BLUE & end.color);
        color->delta_r = (color->end_r - color->start_r);    // Calculate delta for red
        color->delta_g = (color->end_g - color->start_g);    // Calculate delta for green
        color->delta_b = (color->end_b - color->start_b);    // Calculate delta for blue
        return (color);    // Return the initialized color structure
    }


4. color_pallet_init(int min_color, int max_color):
    - Purpose: Initializes a t_color structure for a gradient between two colors.
    - Parameters:
    - int min_color: The starting color.
    - int max_color: The ending color.
    - Returns: A pointer to the initialized t_color structure, or NULL on failure.
    - Code Documentation:

    t_color *color_pallet_init(int min_color, int max_color)
    {
        t_color *color;

        color = malloc(sizeof(t_color));    // Allocate memory for the color structure
        if (!color)
            return (NULL);    // Return NULL if allocation fails

        color->start_color = min_color;    // Initialize start color
        color->start_r = (C_RED & min_color) >> 16;
        color->start_g = (C_GREEN & min_color) >> 8;
        color->start_b = (C_BLUE & min_color);

        color->end_color = max_color;    // Initialize end color
        color->end_r = (C_RED & max_color) >> 16;
        color->end_g = (C_GREEN & max_color) >> 8;
        color->end_b = (C_BLUE & max_color);
        color->delta_r = (color->end_r - color->start_r);    // Calculate delta for red
        color->delta_g = (color->end_g - color->start_g);    // Calculate delta for green
        color->delta_b = (color->end_b - color->start_b);    // Calculate delta for blue
        return (color);    // Return the initialized color structure
    }

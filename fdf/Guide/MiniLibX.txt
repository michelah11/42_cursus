----- INTRODUCTION -----

--- MiniLibX ---
MiniLibX is a minimalistic graphics library designed for basic screen rendering tasks. It offers
straightforward window creation, basic drawing capabilities, limited image functions, and an
unconventional event management system, all without requiring in-depth knowledge of X-Window or
Cocoa.

--- X-Window ---
X-Window is a network-oriented graphical system used on Unix-based systems, facilitating remote
desktop connections. A well-known example of its application is TeamViewer, which allows users
to connect to and control remote desktops.

--- Getting Started ---
For Linux, Codam provides a ZIP file containing a version of MiniLibX that's compatible with
Linux. This version has the same functions and function calls as other versions. However, memory
management for images might differ due to architecture-specific implementations.

The MiniLibX for Linux should be unzipped into a new folder named mlx_linux at the root of the
project. MiniLibX for Linux requires the xorg, libxext-dev, and zlib1g-dev libraries. The
following dependencies need to be installed:

sudo apt-get update && sudo apt-get install xorg libxext-dev zlib1g-dev libbsd-dev

To configure MiniLibX, run the configuration script located in the root of the repository. For
compiling object files, add the following rule to the Makefile, assuming the MiniLibX for Linux
source is in a directory named mlx_linux at the root of the project:

%.o: %.c
	$(CC) -Wall -Wextra -Werror -I/usr/include -Imlx_linux -O3 -c $< -o $@

To link with the required internal Linux API, use the following rule:

$(NAME): $(OBJ)
	$(CC) $(OBJ) -Lmlx_linux -lmlx_Linux -L/usr/lib -Imlx_linux -lXext -lX11 -lm -lz -o $(NAME)

----- INITIALIZATION -----
Before using MiniLibX, include the <mlx.h> header to access all necessary functions. Initialize
MiniLibX by calling the mlx_init function, which establishes a connection to the appropriate
graphical system and returns a void * pointer that holds the location of the MLX instance.

#include <mlx.h>

int main(void)
{
    void *mlx;
    mlx = mlx_init();
}
At this stage, no window is created or rendered. To create a window, use the mlx_new_window
function, specifying the window's width, height, and title. The function returns a pointer to
the newly created window. To render the window and keep it open, call mlx_loop.

int main(void)
{
    void *mlx;
    void *mlx_win;

    mlx = mlx_init();
    mlx_win = mlx_new_window(mlx, 1920, 1080, "Hello world!");
    mlx_loop(mlx);
}

--- Writing Pixels to an Image ---
To draw pixels efficiently, buffer them in an image before rendering them to the window. Directly
using mlx_pixel_put is slow because it attempts to render each pixel immediately. Create an image
using mlx_new_image, which returns a pointer to the image.

#include <mlx.h>

int main(void)
{
    void *mlx;
    void *img;

    mlx = mlx_init();
    img = mlx_new_image(mlx, 1920, 1080);
}
To manipulate pixels in the image, get the memory address of the image data using mlx_get_data_addr.
This function also retrieves the bits per pixel, line length, and endian format.

#include <mlx.h>

typedef struct s_data {
    void *img;
    char *addr;
    int bits_per_pixel;
    int line_length;
    int endian;
} t_data;

int main(void)
{
    void *mlx;
    t_data img;

    mlx = mlx_init();
    img.img = mlx_new_image(mlx, 1920, 1080);
    img.addr = mlx_get_data_addr(img.img, &img.bits_per_pixel, &img.line_length, &img.endian);
}
Calculate the memory offset to write pixels using the formula:

int offset = (y * line_length + x * (bits_per_pixel / 8));
Implement a custom function to write pixels to the image, similar to mlx_pixel_put but optimized:

void my_mlx_pixel_put(t_data *data, int x, int y, int color)
{
    char *dst;

    dst = data->addr + (y * data->line_length + x * (data->bits_per_pixel / 8));
    *(unsigned int *)dst = color;
}
--- Pushing Images to a Window ---
Once the image is created and pixels are written to it, push the image to the window using
mlx_put_image_to_window. This function allows you to display the image on the screen.

#include <mlx.h>

typedef struct s_data {
    void *img;
    char *addr;
    int bits_per_pixel;
    int line_length;
    int endian;
} t_data;

int main(void)
{
    void *mlx;
    void *mlx_win;
    t_data img;

    mlx = mlx_init();
    mlx_win = mlx_new_window(mlx, 1920, 1080, "Hello world!");
    img.img = mlx_new_image(mlx, 1920, 1080);
    img.addr = mlx_get_data_addr(img.img, &img.bits_per_pixel, &img.line_length, &img.endian);

    my_mlx_pixel_put(&img, 5, 5, 0x00FF0000);
    mlx_put_image_to_window(mlx, mlx_win, img.img, 0, 0);

    mlx_loop(mlx);
}

void my_mlx_pixel_put(t_data *data, int x, int y, int color)
{
    char *dst;

    dst = data->addr + (y * data->line_length + x * (data->bits_per_pixel / 8));
    *(unsigned int *)dst = color;
}

----- DRAWING SHAPES -----

-- Drawing a Square --

#include <mlx.h>

typedef struct s_data {
    void *img;
    char *addr;
    int bits_per_pixel;
    int line_length;
    int endian;
} t_data;

void my_mlx_pixel_put(t_data *data, int x, int y, int color)
{
    char *dst;

    dst = data->addr + (y * data->line_length + x * (data->bits_per_pixel / 8));
    *(unsigned int *)dst = color;
}

void draw_square(t_data *data, int x_start, int y_start, int side_length, int color)
{
    for (int y = y_start; y < y_start + side_length; y++)
    {
        for (int x = x_start; x < x_start + side_length; x++)
        {
            my_mlx_pixel_put(data, x, y, color);
        }
    }
}

int main(void)
{
    void *mlx;
    void *mlx_win;
    t_data img;

    mlx = mlx_init();
    mlx_win = mlx_new_window(mlx, 800, 800, "Square");
    img.img = mlx_new_image(mlx, 800, 800);
    img.addr = mlx_get_data_addr(img.img, &img.bits_per_pixel, &img.line_length, &img.endian);

    draw_square(&img, 200, 200, 200, 0x00FF0000); // Draw a red square

    mlx_put_image_to_window(mlx, mlx_win, img.img, 0, 0);
    mlx_loop(mlx);
}

-- Drawing a Circle --

#include <mlx.h>
#include <math.h>

typedef struct s_data {
    void *img;
    char *addr;
    int bits_per_pixel;
    int line_length;
    int endian;
} t_data;

void my_mlx_pixel_put(t_data *data, int x, int y, int color)
{
    char *dst;

    dst = data->addr + (y * data->line_length + x * (data->bits_per_pixel / 8));
    *(unsigned int *)dst = color;
}

void draw_circle(t_data *data, int x_center, int y_center, int radius, int color)
{
    for (int y = -radius; y <= radius; y++)
    {
        for (int x = -radius; x <= radius; x++)
        {
            if (x * x + y * y <= radius * radius)
            {
                my_mlx_pixel_put(data, x_center + x, y_center + y, color);
            }
        }
    }
}

int main(void)
{
    void *mlx;
    void *mlx_win;
    t_data img;

    mlx = mlx_init();
    mlx_win = mlx_new_window(mlx, 800, 800, "Circle");
    img.img = mlx_new_image(mlx, 800, 800);
    img.addr = mlx_get_data_addr(img.img, &img.bits_per_pixel, &img.line_length, &img.endian);

    draw_circle(&img, 400, 400, 100, 0x0000FF00); // Draw a green circle

    mlx_put_image_to_window(mlx, mlx_win, img.img, 0, 0);
    mlx_loop(mlx);
}

-- Drawing a Triangle --

#include <mlx.h>
#include <stdlib.h>

typedef struct s_data {
    void *img;
    char *addr;
    int bits_per_pixel;
    int line_length;
    int endian;
} t_data;

void my_mlx_pixel_put(t_data *data, int x, int y, int color)
{
    char *dst;

    dst = data->addr + (y * data->line_length + x * (data->bits_per_pixel / 8));
    *(unsigned int *)dst = color;
}

void swap(int *a, int *b)
{
    int temp = *a;
    *a = *b;
    *b = temp;
}

void draw_line(t_data *data, int x0, int y0, int x1, int y1, int color)
{
    int dx = abs(x1 - x0);
    int dy = abs(y1 - y0);
    int sx = 1;
    int sy = 1;

    if (x0 >= x1) {
        sx = -1;
    }

    if (y0 >= y1) {
        sy = -1;
    }

    int err = dx - dy;
    int e2;

    while (1)
    {
        my_mlx_pixel_put(data, x0, y0, color);
        if (x0 == x1 && y0 == y1)
            break;
        e2 = 2 * err;
        if (e2 > -dy)
        {
            err -= dy;
            x0 += sx;
        }
        if (e2 < dx)
        {
            err += dx;
            y0 += sy;
        }
    }
}

void draw_filled_triangle(t_data *data, int x0, int y0, int x1, int y1, int x2, int y2, int color)
{
    if (y0 > y1) { swap(&x0, &x1); swap(&y0, &y1); }
    if (y0 > y2) { swap(&x0, &x2); swap(&y0, &y2); }
    if (y1 > y2) { swap(&x1, &x2); swap(&y1, &y2); }

    int total_height = y2 - y0;

    for (int i = 0; i < total_height; i++)
    {
        int second_half = 0;
        if (i > y1 - y0 || y1 == y0) {
            second_half = 1;
        }

        int segment_height;
        if (second_half) {
            segment_height = y2 - y1;
        } else {
            segment_height = y1 - y0;
        }

        float alpha = (float)i / total_height;
        float beta = (float)(i - (second_half ? y1 - y0 : 0)) / segment_height; 

        int A = x0 + (x2 - x0) * alpha;
        int B;
        if (second_half) {
            B = x1 + (x2 - x1) * beta;
        } else {
            B = x0 + (x1 - x0) * beta;
        }

        if (A > B) swap(&A, &B);

        for (int j = A; j <= B; j++)
        {
            my_mlx_pixel_put(data, j, y0 + i, color);
        }
    }
}

int main(void)
{
    void *mlx;
    void *mlx_win;
    t_data img;

    mlx = mlx_init();
    mlx_win = mlx_new_window(mlx, 800, 800, "Triangle");
    img.img = mlx_new_image(mlx, 800, 800);
    img.addr = mlx_get_data_addr(img.img, &img.bits_per_pixel, &img.line_length, &img.endian);

    draw_filled_triangle(&img, 300, 200, 500, 200, 400, 400, 0x00FF0000);

    mlx_put_image_to_window(mlx, mlx_win, img.img, 0, 0);
    mlx_loop(mlx);
}

----- COLORS -----
Color Representation
Colors in MiniLibX are represented as integers using the ARGB format. The integer format
requires bit manipulation to encode and decode the transparency and color components.

Colors in MiniLibX use the TRGB format, where each color component is represented by a
specific portion of the integer:
		T: Transparency
		R: Red component
		G: Green component
		B: Blue component

The color is encoded as 0xTTRRGGBB, where each pair of hex digits represents one of these
components. Here are a few examples:
		Color	TRGB Representation
		Red	0x00FF0000
		Green	0x0000FF00
		Blue	0x000000FF

--- Encoding and Decoding Colors ---
There are two common methods to encode and decode TRGB colors:
		Bit Shifting
		Char/Int Conversion

-- Bit Shifting --
Since each color component fits within a single byte (8 bits), an integer (which is 4 bytes
or 32 bits) can fully contain the TRGB color. Bit shifting is used to place each component
into its correct position within the integer.

- Creating a TRGB Color -

int create_trgb(int t, int r, int g, int b)
{
    return (t << 24 | r << 16 | g << 8 | b);
}

- Extracting Components from TRGB -

int get_t(int trgb)
{
    return ((trgb >> 24) & 0xFF);
}

int get_r(int trgb)
{
    return ((trgb >> 16) & 0xFF);
}

int get_g(int trgb)
{
    return ((trgb >> 8) & 0xFF);
}

int get_b(int trgb)
{
    return (trgb & 0xFF);
}

-- Char/Int Conversion --
Another method for handling TRGB colors is through direct conversion between char and int
types. Each char (1 byte) represents one component of the TRGB color, and these bytes can
be packed into an int (4 bytes).

- Creating a TRGB Color with Char/Int Conversion -

int create_trgb(unsigned char t, unsigned char r, unsigned char g, unsigned char b)
{
    return (*(int *)(unsigned char[4]){b, g, r, t});
}

- Extracting Components from TRGB with Char/Int Conversion -

unsigned char get_t(int trgb)
{
    return (((unsigned char *)&trgb)[3]);
}

unsigned char get_r(int trgb)
{
    return (((unsigned char *)&trgb)[2]);
}

unsigned char get_g(int trgb)
{
    return (((unsigned char *)&trgb)[1]);
}

unsigned char get_b(int trgb)
{
    return (((unsigned char *)&trgb)[0]);
}

-- Memory Layout Example --
To help visualize this, consider the memory layout of a TRGB integer. If the address of
the int trgb variable is 0x0FAE1, the components are stored in memory as follows:
		Address	Char			Int
		0x0FAE1	unsigned char b	int trgb
		0x0FAE2	unsigned char g	[allocated]
		0x0FAE3	unsigned char r	[allocated]
		0x0FAE4	unsigned char t	[allocated]

In this representation, each char directly corresponds to one of the color components.

----- EVENTS -----
Events are fundamental to writing interactive applications in MiniLibX. Understanding how
to work with events is crucial for developing graphical projects. In MiniLibX, events are
handled through hooks, which are functions that get called whenever a specific event is
triggered.

--- X11 Interface ---
X11 is a library commonly used alongside MiniLibX, providing a variety of events that can
be leveraged in graphical applications. Understanding X11 events is beneficial when working
with MiniLibX on platforms that support it.

--- X11 Events ---
Here are some key X11 events that you may encounter:
			Key	Event
			02	KeyPress
			03	KeyRelease
			04	ButtonPress
			05	ButtonRelease
			06	MotionNotify
			07	EnterNotify
			08	LeaveNotify
			09	FocusIn
			10	FocusOut
			11	KeymapNotify
			12	Expose
			13	GraphicsExpose
			14	NoExpose
			15	VisibilityNotify
			16	CreateNotify
			17	DestroyNotify
			18	UnmapNotify
			19	MapNotify
			20	MapRequest
			21	ReparentNotify
			22	ConfigureNotify
			23	ConfigureRequest
			24	GravityNotify
			25	ResizeRequest
			26	CirculateNotify
			27	CirculateRequest
			28	PropertyNotify
			29	SelectionClear
			30	SelectionRequest
			31	SelectionNotify
			32	ColormapNotify
			33	ClientMessage
			34	MappingNotify
			35	GenericEvent
			36	LASTEvent
--- X11 Masks ---
Each X11 event has an associated mask, allowing you to filter which events to listen for.
Key masks enable you to whitelist or blacklist specific events in your application. Below
are some common X11 masks:
			Mask		Description
			0L		NoEventMask
			(1L<<0)	KeyPressMask
			(1L<<1)	KeyReleaseMask
			(1L<<2)	ButtonPressMask
			(1L<<3)	ButtonReleaseMask
			(1L<<4)	EnterWindowMask
			(1L<<5)	LeaveWindowMask
			(1L<<6)	PointerMotionMask
			(1L<<7)	PointerMotionHintMask
			(1L<<8)	Button1MotionMask
			(1L<<9)	Button2MotionMask
			(1L<<10)	Button3MotionMask
			(1L<<11)	Button4MotionMask
			(1L<<12)	Button5MotionMask
			(1L<<13)	ButtonMotionMask
			(1L<<14)	KeymapStateMask
			(1L<<15)	ExposureMask
			(1L<<16)	VisibilityChangeMask
			(1L<<17)	StructureNotifyMask
			(1L<<18)	ResizeRedirectMask
			(1L<<19)	SubstructureNotifyMask
			(1L<<20)	SubstructureRedirectMask
			(1L<<21)	FocusChangeMask
			(1L<<22)	PropertyChangeMask
			(1L<<23)	ColormapChangeMask
			(1L<<24)	OwnerGrabButtonMask

--- Hooking into Events ---
Using mlx_hook:
Hooking into events is one of the most powerful features in MiniLibX, allowing you to register
functions that respond to specific events.

void mlx_hook(mlx_win_list_t *win_ptr, int x_event, int x_mask, int (*f)(), void *param);
win_ptr: Pointer to the window.
x_event: The event you want to listen to.
x_mask: The event mask (note: not used on macOS).
f: The function to be called when the event occurs.
param: Additional parameters passed to the event function.
Event Function Prototypes
Event functions have different prototypes depending on the event being hooked:

Hooking Event	Code		Prototype
ON_KEYDOWN		2		int (*f)(int keycode, void *param)
ON_KEYUP		3		int (*f)(int keycode, void *param)
ON_MOUSEDOWN	4		int (*f)(int button, int x, int y, void *param)
ON_MOUSEUP		5		int (*f)(int button, int x, int y, void *param)
ON_MOUSEMOVE	6		int (*f)(int x, int y, void *param)
ON_EXPOSE		12		int (*f)(void *param)
ON_DESTROY		17		int (*f)(void *param)

--- Hooking Aliases ---
MiniLibX provides alias functions for some common hooks:

mlx_expose_hook: Alias for hooking the expose event (ON_EXPOSE).
mlx_key_hook: Alias for hooking the key up event (ON_KEYUP).
mlx_mouse_hook: Alias for hooking the mouse down event (ON_MOUSEDOWN).
Hooking
Hooking in computer programming refers to techniques that modify or extend the behavior of software
by intercepting function calls, events, or messages passed between components. This concept is
crucial in MiniLibX, as it allows you to interact with the graphical environment by responding to
various events.

--- Introduction to Hooking ---
Hooking serves multiple purposes, including debugging, extending functionality, and monitoring
behavior. For example, you might intercept keyboard or mouse events before they reach an application
or intercept operating system calls to modify an application's function. Hooking is also common in
benchmarking programs, such as those measuring frame rates in 3D games.

In MiniLibX, hooking forms the backbone of event-driven programming, enabling developers to respond
to user interactions like key presses, mouse movements, and clicks.

-- Hooking into Key Events --
Hooking key events might seem complex, but it’s straightforward in MiniLibX. Let’s explore a simple
example:

#include <mlx.h>
#include <stdio.h>

typedef struct s_vars {
    void *mlx;
    void *win;
} t_vars;

int key_hook(int keycode, t_vars *vars)
{
    printf("Hello from key_hook!\n");
    return (0);
}

int main(void)
{
    t_vars vars;

    vars.mlx = mlx_init();
    vars.win = mlx_new_window(vars.mlx, 640, 480, "Hello world!");
    mlx_key_hook(vars.win, key_hook, &vars);
    mlx_loop(vars.mlx);
}
key_hook prints a message whenever a key is pressed. The key hook is set up using mlx_key_hook,
which internally calls mlx_hook with the appropriate X11 event types. When you press any key,
"Hello from key_hook!" is printed to the console.

Note: The mlx_key_hook function is an alias for setting up a hook on the key up event (ON_KEYUP).

-- Hooking into Mouse Events --
Similar to key events, you can also hook into mouse events in MiniLibX. This allows you to
respond to mouse actions like clicks and scrolling.

mlx_mouse_hook(vars.win, mouse_hook, &vars);

----- LOOPS -----

--- Understanding Loops in MiniLibX ---
Loops in MiniLibX are a mechanism that allows continuous rendering of new frames, creating
animations. The mlx_loop function keeps the program running, while the mlx_loop_hook
function allows you to register a callback that will be called on each frame. This
callback is where you update the contents of the window to create animations.

--- Hooking into Loops ---
To initiate a loop, use the mlx_loop function with the mlx instance as its only parameter.

#include <mlx.h>

int main(void)
{
    void *mlx;

    // Initialize the connection to the graphical system
    mlx = mlx_init();

    // Enter the loop (this will keep the window open)
    mlx_loop(mlx);
}

Note: This code will not produce any visible output since no loop hook is registered to
handle frame rendering. To display something, you need to register a loop hook that will
render frames continuously.

--- Registering a Loop Hook ---
To create an animation, you need to create a window and use mlx_loop_hook to register a
function that will be called on each frame. This function should update the contents of
the window accordingly.

#include <mlx.h>

// Define the function that will be called on each frame
int render_next_frame(void *YourStruct)
{
    // Your rendering logic here (e.g., move an object, change colors)
    
    return (0);  // Returning 0 continues the loop
}

int main(void)
{
    void *mlx;
    void *win;
    YourStructType YourStruct;  // Replace with your actual structure

    // Initialize the connection to the graphical system
    mlx = mlx_init();

    // Create a new window
    win = mlx_new_window(mlx, 800, 600, "Animation Example");

    // Register the render_next_frame function to be called on each frame
    mlx_loop_hook(mlx, render_next_frame, &YourStruct);

    // Enter the loop to keep the window open and render frames
    mlx_loop(mlx);
}

-- Explanation --
mlx_loop Function: This function keeps the MiniLibX window open and responsive. It must
be called after setting up the window and hooks. It’s the backbone of your application’s
main loop.

mlx_loop_hook Function:
Registers a callback function (render_next_frame in this case) that will be called
repeatedly by mlx_loop. This function is where you update your frame's content, creating
the effect of animation.

render_next_frame Function:
This function is where you implement the logic for each frame. For example, you could
move an object, change colors, or redraw the entire screen. The parameter YourStruct is
passed to this function and can be used to maintain the state between frames (e.g., an
object’s position).

State Persistence
Since YourStruct is a pointer, the state of your application can persist across multiple
calls to render_next_frame. This allows you to incrementally update the animation.

--- Moving a Square ---
Here’s a practical example where a square moves horizontally across the screen:

#include <mlx.h>

typedef struct {
    void *mlx;
    void *win;
    int x;
} t_data;

int render_next_frame(t_data *data)
{
    // Clear the window (optional, depending on the effect you want)
    mlx_clear_window(data->mlx, data->win);

    // Draw a square at the current position
    mlx_pixel_put(data->mlx, data->win, data->x, 250, 0x00FF0000);

    // Update the position for the next frame
    data->x += 5;

    // Loop the square back to the start when it reaches the window edge
    if (data->x > 800)
        data->x = 0;

    return (0);
}

int main(void)
{
    t_data data;

    // Initialize MiniLibX and create a window
    data.mlx = mlx_init();
    data.win = mlx_new_window(data.mlx, 800, 600, "Moving Square");

    // Initialize the starting position of the square
    data.x = 0;

    // Register the loop hook to continuously update the frame
    mlx_loop_hook(data.mlx, render_next_frame, &data);

    // Start the loop
    mlx_loop(data.mlx);
}

-- Explanation --
t_data Structure: This structure holds the necessary data, such as the current position
of the square (x), and the MiniLibX instance (mlx) and window (win).
render_next_frame Function: Moves the square across the screen. The square’s position
(x) is incremented on each frame, and the square loops back to the start when it reaches
the edge of the window.
Animation Loop: The mlx_loop_hook registers render_next_frame to be called continuously,
creating the animation.